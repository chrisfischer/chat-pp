// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: client_server.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_client_5fserver_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_client_5fserver_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3011000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3011004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_client_5fserver_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_client_5fserver_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[7]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_client_5fserver_2eproto;
namespace client_server {
class ChatRoom;
class ChatRoomDefaultTypeInternal;
extern ChatRoomDefaultTypeInternal _ChatRoom_default_instance_;
class Message;
class MessageDefaultTypeInternal;
extern MessageDefaultTypeInternal _Message_default_instance_;
class Request;
class RequestDefaultTypeInternal;
extern RequestDefaultTypeInternal _Request_default_instance_;
class RequestResult;
class RequestResultDefaultTypeInternal;
extern RequestResultDefaultTypeInternal _RequestResult_default_instance_;
class User;
class UserDefaultTypeInternal;
extern UserDefaultTypeInternal _User_default_instance_;
class Vote;
class VoteDefaultTypeInternal;
extern VoteDefaultTypeInternal _Vote_default_instance_;
class VotingInfo;
class VotingInfoDefaultTypeInternal;
extern VotingInfoDefaultTypeInternal _VotingInfo_default_instance_;
}  // namespace client_server
PROTOBUF_NAMESPACE_OPEN
template<> ::client_server::ChatRoom* Arena::CreateMaybeMessage<::client_server::ChatRoom>(Arena*);
template<> ::client_server::Message* Arena::CreateMaybeMessage<::client_server::Message>(Arena*);
template<> ::client_server::Request* Arena::CreateMaybeMessage<::client_server::Request>(Arena*);
template<> ::client_server::RequestResult* Arena::CreateMaybeMessage<::client_server::RequestResult>(Arena*);
template<> ::client_server::User* Arena::CreateMaybeMessage<::client_server::User>(Arena*);
template<> ::client_server::Vote* Arena::CreateMaybeMessage<::client_server::Vote>(Arena*);
template<> ::client_server::VotingInfo* Arena::CreateMaybeMessage<::client_server::VotingInfo>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace client_server {

enum Request_RequestType : int {
  Request_RequestType_ENTER = 0,
  Request_RequestType_EXIT = 1,
  Request_RequestType_CHANGE_NAME = 2,
  Request_RequestType_Request_RequestType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Request_RequestType_Request_RequestType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Request_RequestType_IsValid(int value);
constexpr Request_RequestType Request_RequestType_RequestType_MIN = Request_RequestType_ENTER;
constexpr Request_RequestType Request_RequestType_RequestType_MAX = Request_RequestType_CHANGE_NAME;
constexpr int Request_RequestType_RequestType_ARRAYSIZE = Request_RequestType_RequestType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Request_RequestType_descriptor();
template<typename T>
inline const std::string& Request_RequestType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Request_RequestType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Request_RequestType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Request_RequestType_descriptor(), enum_t_value);
}
inline bool Request_RequestType_Parse(
    const std::string& name, Request_RequestType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Request_RequestType>(
    Request_RequestType_descriptor(), name, value);
}
// ===================================================================

class User :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:client_server.User) */ {
 public:
  User();
  virtual ~User();

  User(const User& from);
  User(User&& from) noexcept
    : User() {
    *this = ::std::move(from);
  }

  inline User& operator=(const User& from) {
    CopyFrom(from);
    return *this;
  }
  inline User& operator=(User&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const User& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const User* internal_default_instance() {
    return reinterpret_cast<const User*>(
               &_User_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(User& a, User& b) {
    a.Swap(&b);
  }
  inline void Swap(User* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline User* New() const final {
    return CreateMaybeMessage<User>(nullptr);
  }

  User* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<User>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const User& from);
  void MergeFrom(const User& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(User* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "client_server.User";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_client_5fserver_2eproto);
    return ::descriptor_table_client_5fserver_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIDFieldNumber = 1,
  };
  // string userID = 1;
  void clear_userid();
  const std::string& userid() const;
  void set_userid(const std::string& value);
  void set_userid(std::string&& value);
  void set_userid(const char* value);
  void set_userid(const char* value, size_t size);
  std::string* mutable_userid();
  std::string* release_userid();
  void set_allocated_userid(std::string* userid);
  private:
  const std::string& _internal_userid() const;
  void _internal_set_userid(const std::string& value);
  std::string* _internal_mutable_userid();
  public:

  // @@protoc_insertion_point(class_scope:client_server.User)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr userid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_client_5fserver_2eproto;
};
// -------------------------------------------------------------------

class Message :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:client_server.Message) */ {
 public:
  Message();
  virtual ~Message();

  Message(const Message& from);
  Message(Message&& from) noexcept
    : Message() {
    *this = ::std::move(from);
  }

  inline Message& operator=(const Message& from) {
    CopyFrom(from);
    return *this;
  }
  inline Message& operator=(Message&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Message& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Message* internal_default_instance() {
    return reinterpret_cast<const Message*>(
               &_Message_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Message& a, Message& b) {
    a.Swap(&b);
  }
  inline void Swap(Message* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Message* New() const final {
    return CreateMaybeMessage<Message>(nullptr);
  }

  Message* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Message>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Message& from);
  void MergeFrom(const Message& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Message* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "client_server.Message";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_client_5fserver_2eproto);
    return ::descriptor_table_client_5fserver_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContentFieldNumber = 1,
    kTimeFieldNumber = 3,
    kSenderFieldNumber = 2,
  };
  // string content = 1;
  void clear_content();
  const std::string& content() const;
  void set_content(const std::string& value);
  void set_content(std::string&& value);
  void set_content(const char* value);
  void set_content(const char* value, size_t size);
  std::string* mutable_content();
  std::string* release_content();
  void set_allocated_content(std::string* content);
  private:
  const std::string& _internal_content() const;
  void _internal_set_content(const std::string& value);
  std::string* _internal_mutable_content();
  public:

  // string time = 3;
  void clear_time();
  const std::string& time() const;
  void set_time(const std::string& value);
  void set_time(std::string&& value);
  void set_time(const char* value);
  void set_time(const char* value, size_t size);
  std::string* mutable_time();
  std::string* release_time();
  void set_allocated_time(std::string* time);
  private:
  const std::string& _internal_time() const;
  void _internal_set_time(const std::string& value);
  std::string* _internal_mutable_time();
  public:

  // .client_server.User sender = 2;
  bool has_sender() const;
  private:
  bool _internal_has_sender() const;
  public:
  void clear_sender();
  const ::client_server::User& sender() const;
  ::client_server::User* release_sender();
  ::client_server::User* mutable_sender();
  void set_allocated_sender(::client_server::User* sender);
  private:
  const ::client_server::User& _internal_sender() const;
  ::client_server::User* _internal_mutable_sender();
  public:

  // @@protoc_insertion_point(class_scope:client_server.Message)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr content_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr time_;
  ::client_server::User* sender_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_client_5fserver_2eproto;
};
// -------------------------------------------------------------------

class ChatRoom :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:client_server.ChatRoom) */ {
 public:
  ChatRoom();
  virtual ~ChatRoom();

  ChatRoom(const ChatRoom& from);
  ChatRoom(ChatRoom&& from) noexcept
    : ChatRoom() {
    *this = ::std::move(from);
  }

  inline ChatRoom& operator=(const ChatRoom& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChatRoom& operator=(ChatRoom&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ChatRoom& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ChatRoom* internal_default_instance() {
    return reinterpret_cast<const ChatRoom*>(
               &_ChatRoom_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ChatRoom& a, ChatRoom& b) {
    a.Swap(&b);
  }
  inline void Swap(ChatRoom* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ChatRoom* New() const final {
    return CreateMaybeMessage<ChatRoom>(nullptr);
  }

  ChatRoom* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ChatRoom>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ChatRoom& from);
  void MergeFrom(const ChatRoom& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChatRoom* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "client_server.ChatRoom";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_client_5fserver_2eproto);
    return ::descriptor_table_client_5fserver_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChatRoomIDFieldNumber = 1,
  };
  // string chatRoomID = 1;
  void clear_chatroomid();
  const std::string& chatroomid() const;
  void set_chatroomid(const std::string& value);
  void set_chatroomid(std::string&& value);
  void set_chatroomid(const char* value);
  void set_chatroomid(const char* value, size_t size);
  std::string* mutable_chatroomid();
  std::string* release_chatroomid();
  void set_allocated_chatroomid(std::string* chatroomid);
  private:
  const std::string& _internal_chatroomid() const;
  void _internal_set_chatroomid(const std::string& value);
  std::string* _internal_mutable_chatroomid();
  public:

  // @@protoc_insertion_point(class_scope:client_server.ChatRoom)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr chatroomid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_client_5fserver_2eproto;
};
// -------------------------------------------------------------------

class Request :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:client_server.Request) */ {
 public:
  Request();
  virtual ~Request();

  Request(const Request& from);
  Request(Request&& from) noexcept
    : Request() {
    *this = ::std::move(from);
  }

  inline Request& operator=(const Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline Request& operator=(Request&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Request& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Request* internal_default_instance() {
    return reinterpret_cast<const Request*>(
               &_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Request& a, Request& b) {
    a.Swap(&b);
  }
  inline void Swap(Request* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Request* New() const final {
    return CreateMaybeMessage<Request>(nullptr);
  }

  Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Request>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Request& from);
  void MergeFrom(const Request& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Request* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "client_server.Request";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_client_5fserver_2eproto);
    return ::descriptor_table_client_5fserver_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef Request_RequestType RequestType;
  static constexpr RequestType ENTER =
    Request_RequestType_ENTER;
  static constexpr RequestType EXIT =
    Request_RequestType_EXIT;
  static constexpr RequestType CHANGE_NAME =
    Request_RequestType_CHANGE_NAME;
  static inline bool RequestType_IsValid(int value) {
    return Request_RequestType_IsValid(value);
  }
  static constexpr RequestType RequestType_MIN =
    Request_RequestType_RequestType_MIN;
  static constexpr RequestType RequestType_MAX =
    Request_RequestType_RequestType_MAX;
  static constexpr int RequestType_ARRAYSIZE =
    Request_RequestType_RequestType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  RequestType_descriptor() {
    return Request_RequestType_descriptor();
  }
  template<typename T>
  static inline const std::string& RequestType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, RequestType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function RequestType_Name.");
    return Request_RequestType_Name(enum_t_value);
  }
  static inline bool RequestType_Parse(const std::string& name,
      RequestType* value) {
    return Request_RequestType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kInfoFieldNumber = 3,
    kChatRoomFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // string info = 3;
  void clear_info();
  const std::string& info() const;
  void set_info(const std::string& value);
  void set_info(std::string&& value);
  void set_info(const char* value);
  void set_info(const char* value, size_t size);
  std::string* mutable_info();
  std::string* release_info();
  void set_allocated_info(std::string* info);
  private:
  const std::string& _internal_info() const;
  void _internal_set_info(const std::string& value);
  std::string* _internal_mutable_info();
  public:

  // .client_server.ChatRoom chatRoom = 2;
  bool has_chatroom() const;
  private:
  bool _internal_has_chatroom() const;
  public:
  void clear_chatroom();
  const ::client_server::ChatRoom& chatroom() const;
  ::client_server::ChatRoom* release_chatroom();
  ::client_server::ChatRoom* mutable_chatroom();
  void set_allocated_chatroom(::client_server::ChatRoom* chatroom);
  private:
  const ::client_server::ChatRoom& _internal_chatroom() const;
  ::client_server::ChatRoom* _internal_mutable_chatroom();
  public:

  // .client_server.Request.RequestType type = 1;
  void clear_type();
  ::client_server::Request_RequestType type() const;
  void set_type(::client_server::Request_RequestType value);
  private:
  ::client_server::Request_RequestType _internal_type() const;
  void _internal_set_type(::client_server::Request_RequestType value);
  public:

  // @@protoc_insertion_point(class_scope:client_server.Request)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr info_;
  ::client_server::ChatRoom* chatroom_;
  int type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_client_5fserver_2eproto;
};
// -------------------------------------------------------------------

class RequestResult :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:client_server.RequestResult) */ {
 public:
  RequestResult();
  virtual ~RequestResult();

  RequestResult(const RequestResult& from);
  RequestResult(RequestResult&& from) noexcept
    : RequestResult() {
    *this = ::std::move(from);
  }

  inline RequestResult& operator=(const RequestResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestResult& operator=(RequestResult&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RequestResult& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RequestResult* internal_default_instance() {
    return reinterpret_cast<const RequestResult*>(
               &_RequestResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(RequestResult& a, RequestResult& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestResult* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RequestResult* New() const final {
    return CreateMaybeMessage<RequestResult>(nullptr);
  }

  RequestResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RequestResult>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RequestResult& from);
  void MergeFrom(const RequestResult& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestResult* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "client_server.RequestResult";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_client_5fserver_2eproto);
    return ::descriptor_table_client_5fserver_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRequestFieldNumber = 2,
    kSuccessFieldNumber = 1,
  };
  // .client_server.Request request = 2;
  bool has_request() const;
  private:
  bool _internal_has_request() const;
  public:
  void clear_request();
  const ::client_server::Request& request() const;
  ::client_server::Request* release_request();
  ::client_server::Request* mutable_request();
  void set_allocated_request(::client_server::Request* request);
  private:
  const ::client_server::Request& _internal_request() const;
  ::client_server::Request* _internal_mutable_request();
  public:

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:client_server.RequestResult)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::client_server::Request* request_;
  bool success_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_client_5fserver_2eproto;
};
// -------------------------------------------------------------------

class VotingInfo :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:client_server.VotingInfo) */ {
 public:
  VotingInfo();
  virtual ~VotingInfo();

  VotingInfo(const VotingInfo& from);
  VotingInfo(VotingInfo&& from) noexcept
    : VotingInfo() {
    *this = ::std::move(from);
  }

  inline VotingInfo& operator=(const VotingInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline VotingInfo& operator=(VotingInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const VotingInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VotingInfo* internal_default_instance() {
    return reinterpret_cast<const VotingInfo*>(
               &_VotingInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(VotingInfo& a, VotingInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(VotingInfo* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline VotingInfo* New() const final {
    return CreateMaybeMessage<VotingInfo>(nullptr);
  }

  VotingInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<VotingInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const VotingInfo& from);
  void MergeFrom(const VotingInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VotingInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "client_server.VotingInfo";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_client_5fserver_2eproto);
    return ::descriptor_table_client_5fserver_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRequesterFieldNumber = 1,
    kChatRoomFieldNumber = 2,
  };
  // .client_server.User requester = 1;
  bool has_requester() const;
  private:
  bool _internal_has_requester() const;
  public:
  void clear_requester();
  const ::client_server::User& requester() const;
  ::client_server::User* release_requester();
  ::client_server::User* mutable_requester();
  void set_allocated_requester(::client_server::User* requester);
  private:
  const ::client_server::User& _internal_requester() const;
  ::client_server::User* _internal_mutable_requester();
  public:

  // .client_server.ChatRoom chatRoom = 2;
  bool has_chatroom() const;
  private:
  bool _internal_has_chatroom() const;
  public:
  void clear_chatroom();
  const ::client_server::ChatRoom& chatroom() const;
  ::client_server::ChatRoom* release_chatroom();
  ::client_server::ChatRoom* mutable_chatroom();
  void set_allocated_chatroom(::client_server::ChatRoom* chatroom);
  private:
  const ::client_server::ChatRoom& _internal_chatroom() const;
  ::client_server::ChatRoom* _internal_mutable_chatroom();
  public:

  // @@protoc_insertion_point(class_scope:client_server.VotingInfo)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::client_server::User* requester_;
  ::client_server::ChatRoom* chatroom_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_client_5fserver_2eproto;
};
// -------------------------------------------------------------------

class Vote :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:client_server.Vote) */ {
 public:
  Vote();
  virtual ~Vote();

  Vote(const Vote& from);
  Vote(Vote&& from) noexcept
    : Vote() {
    *this = ::std::move(from);
  }

  inline Vote& operator=(const Vote& from) {
    CopyFrom(from);
    return *this;
  }
  inline Vote& operator=(Vote&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Vote& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Vote* internal_default_instance() {
    return reinterpret_cast<const Vote*>(
               &_Vote_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Vote& a, Vote& b) {
    a.Swap(&b);
  }
  inline void Swap(Vote* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Vote* New() const final {
    return CreateMaybeMessage<Vote>(nullptr);
  }

  Vote* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Vote>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Vote& from);
  void MergeFrom(const Vote& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Vote* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "client_server.Vote";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_client_5fserver_2eproto);
    return ::descriptor_table_client_5fserver_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVoteInfoFieldNumber = 2,
    kVoterFieldNumber = 3,
    kApprovedFieldNumber = 1,
  };
  // .client_server.VotingInfo voteInfo = 2;
  bool has_voteinfo() const;
  private:
  bool _internal_has_voteinfo() const;
  public:
  void clear_voteinfo();
  const ::client_server::VotingInfo& voteinfo() const;
  ::client_server::VotingInfo* release_voteinfo();
  ::client_server::VotingInfo* mutable_voteinfo();
  void set_allocated_voteinfo(::client_server::VotingInfo* voteinfo);
  private:
  const ::client_server::VotingInfo& _internal_voteinfo() const;
  ::client_server::VotingInfo* _internal_mutable_voteinfo();
  public:

  // .client_server.User voter = 3;
  bool has_voter() const;
  private:
  bool _internal_has_voter() const;
  public:
  void clear_voter();
  const ::client_server::User& voter() const;
  ::client_server::User* release_voter();
  ::client_server::User* mutable_voter();
  void set_allocated_voter(::client_server::User* voter);
  private:
  const ::client_server::User& _internal_voter() const;
  ::client_server::User* _internal_mutable_voter();
  public:

  // bool approved = 1;
  void clear_approved();
  bool approved() const;
  void set_approved(bool value);
  private:
  bool _internal_approved() const;
  void _internal_set_approved(bool value);
  public:

  // @@protoc_insertion_point(class_scope:client_server.Vote)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::client_server::VotingInfo* voteinfo_;
  ::client_server::User* voter_;
  bool approved_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_client_5fserver_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// User

// string userID = 1;
inline void User::clear_userid() {
  userid_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& User::userid() const {
  // @@protoc_insertion_point(field_get:client_server.User.userID)
  return _internal_userid();
}
inline void User::set_userid(const std::string& value) {
  _internal_set_userid(value);
  // @@protoc_insertion_point(field_set:client_server.User.userID)
}
inline std::string* User::mutable_userid() {
  // @@protoc_insertion_point(field_mutable:client_server.User.userID)
  return _internal_mutable_userid();
}
inline const std::string& User::_internal_userid() const {
  return userid_.GetNoArena();
}
inline void User::_internal_set_userid(const std::string& value) {
  
  userid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void User::set_userid(std::string&& value) {
  
  userid_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:client_server.User.userID)
}
inline void User::set_userid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  userid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:client_server.User.userID)
}
inline void User::set_userid(const char* value, size_t size) {
  
  userid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:client_server.User.userID)
}
inline std::string* User::_internal_mutable_userid() {
  
  return userid_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* User::release_userid() {
  // @@protoc_insertion_point(field_release:client_server.User.userID)
  
  return userid_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void User::set_allocated_userid(std::string* userid) {
  if (userid != nullptr) {
    
  } else {
    
  }
  userid_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), userid);
  // @@protoc_insertion_point(field_set_allocated:client_server.User.userID)
}

// -------------------------------------------------------------------

// Message

// string content = 1;
inline void Message::clear_content() {
  content_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& Message::content() const {
  // @@protoc_insertion_point(field_get:client_server.Message.content)
  return _internal_content();
}
inline void Message::set_content(const std::string& value) {
  _internal_set_content(value);
  // @@protoc_insertion_point(field_set:client_server.Message.content)
}
inline std::string* Message::mutable_content() {
  // @@protoc_insertion_point(field_mutable:client_server.Message.content)
  return _internal_mutable_content();
}
inline const std::string& Message::_internal_content() const {
  return content_.GetNoArena();
}
inline void Message::_internal_set_content(const std::string& value) {
  
  content_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void Message::set_content(std::string&& value) {
  
  content_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:client_server.Message.content)
}
inline void Message::set_content(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  content_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:client_server.Message.content)
}
inline void Message::set_content(const char* value, size_t size) {
  
  content_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:client_server.Message.content)
}
inline std::string* Message::_internal_mutable_content() {
  
  return content_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Message::release_content() {
  // @@protoc_insertion_point(field_release:client_server.Message.content)
  
  return content_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Message::set_allocated_content(std::string* content) {
  if (content != nullptr) {
    
  } else {
    
  }
  content_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), content);
  // @@protoc_insertion_point(field_set_allocated:client_server.Message.content)
}

// .client_server.User sender = 2;
inline bool Message::_internal_has_sender() const {
  return this != internal_default_instance() && sender_ != nullptr;
}
inline bool Message::has_sender() const {
  return _internal_has_sender();
}
inline void Message::clear_sender() {
  if (GetArenaNoVirtual() == nullptr && sender_ != nullptr) {
    delete sender_;
  }
  sender_ = nullptr;
}
inline const ::client_server::User& Message::_internal_sender() const {
  const ::client_server::User* p = sender_;
  return p != nullptr ? *p : *reinterpret_cast<const ::client_server::User*>(
      &::client_server::_User_default_instance_);
}
inline const ::client_server::User& Message::sender() const {
  // @@protoc_insertion_point(field_get:client_server.Message.sender)
  return _internal_sender();
}
inline ::client_server::User* Message::release_sender() {
  // @@protoc_insertion_point(field_release:client_server.Message.sender)
  
  ::client_server::User* temp = sender_;
  sender_ = nullptr;
  return temp;
}
inline ::client_server::User* Message::_internal_mutable_sender() {
  
  if (sender_ == nullptr) {
    auto* p = CreateMaybeMessage<::client_server::User>(GetArenaNoVirtual());
    sender_ = p;
  }
  return sender_;
}
inline ::client_server::User* Message::mutable_sender() {
  // @@protoc_insertion_point(field_mutable:client_server.Message.sender)
  return _internal_mutable_sender();
}
inline void Message::set_allocated_sender(::client_server::User* sender) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete sender_;
  }
  if (sender) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      sender = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sender, submessage_arena);
    }
    
  } else {
    
  }
  sender_ = sender;
  // @@protoc_insertion_point(field_set_allocated:client_server.Message.sender)
}

// string time = 3;
inline void Message::clear_time() {
  time_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& Message::time() const {
  // @@protoc_insertion_point(field_get:client_server.Message.time)
  return _internal_time();
}
inline void Message::set_time(const std::string& value) {
  _internal_set_time(value);
  // @@protoc_insertion_point(field_set:client_server.Message.time)
}
inline std::string* Message::mutable_time() {
  // @@protoc_insertion_point(field_mutable:client_server.Message.time)
  return _internal_mutable_time();
}
inline const std::string& Message::_internal_time() const {
  return time_.GetNoArena();
}
inline void Message::_internal_set_time(const std::string& value) {
  
  time_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void Message::set_time(std::string&& value) {
  
  time_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:client_server.Message.time)
}
inline void Message::set_time(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  time_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:client_server.Message.time)
}
inline void Message::set_time(const char* value, size_t size) {
  
  time_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:client_server.Message.time)
}
inline std::string* Message::_internal_mutable_time() {
  
  return time_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Message::release_time() {
  // @@protoc_insertion_point(field_release:client_server.Message.time)
  
  return time_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Message::set_allocated_time(std::string* time) {
  if (time != nullptr) {
    
  } else {
    
  }
  time_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), time);
  // @@protoc_insertion_point(field_set_allocated:client_server.Message.time)
}

// -------------------------------------------------------------------

// ChatRoom

// string chatRoomID = 1;
inline void ChatRoom::clear_chatroomid() {
  chatroomid_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& ChatRoom::chatroomid() const {
  // @@protoc_insertion_point(field_get:client_server.ChatRoom.chatRoomID)
  return _internal_chatroomid();
}
inline void ChatRoom::set_chatroomid(const std::string& value) {
  _internal_set_chatroomid(value);
  // @@protoc_insertion_point(field_set:client_server.ChatRoom.chatRoomID)
}
inline std::string* ChatRoom::mutable_chatroomid() {
  // @@protoc_insertion_point(field_mutable:client_server.ChatRoom.chatRoomID)
  return _internal_mutable_chatroomid();
}
inline const std::string& ChatRoom::_internal_chatroomid() const {
  return chatroomid_.GetNoArena();
}
inline void ChatRoom::_internal_set_chatroomid(const std::string& value) {
  
  chatroomid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void ChatRoom::set_chatroomid(std::string&& value) {
  
  chatroomid_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:client_server.ChatRoom.chatRoomID)
}
inline void ChatRoom::set_chatroomid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  chatroomid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:client_server.ChatRoom.chatRoomID)
}
inline void ChatRoom::set_chatroomid(const char* value, size_t size) {
  
  chatroomid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:client_server.ChatRoom.chatRoomID)
}
inline std::string* ChatRoom::_internal_mutable_chatroomid() {
  
  return chatroomid_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ChatRoom::release_chatroomid() {
  // @@protoc_insertion_point(field_release:client_server.ChatRoom.chatRoomID)
  
  return chatroomid_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ChatRoom::set_allocated_chatroomid(std::string* chatroomid) {
  if (chatroomid != nullptr) {
    
  } else {
    
  }
  chatroomid_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), chatroomid);
  // @@protoc_insertion_point(field_set_allocated:client_server.ChatRoom.chatRoomID)
}

// -------------------------------------------------------------------

// Request

// .client_server.Request.RequestType type = 1;
inline void Request::clear_type() {
  type_ = 0;
}
inline ::client_server::Request_RequestType Request::_internal_type() const {
  return static_cast< ::client_server::Request_RequestType >(type_);
}
inline ::client_server::Request_RequestType Request::type() const {
  // @@protoc_insertion_point(field_get:client_server.Request.type)
  return _internal_type();
}
inline void Request::_internal_set_type(::client_server::Request_RequestType value) {
  
  type_ = value;
}
inline void Request::set_type(::client_server::Request_RequestType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:client_server.Request.type)
}

// .client_server.ChatRoom chatRoom = 2;
inline bool Request::_internal_has_chatroom() const {
  return this != internal_default_instance() && chatroom_ != nullptr;
}
inline bool Request::has_chatroom() const {
  return _internal_has_chatroom();
}
inline void Request::clear_chatroom() {
  if (GetArenaNoVirtual() == nullptr && chatroom_ != nullptr) {
    delete chatroom_;
  }
  chatroom_ = nullptr;
}
inline const ::client_server::ChatRoom& Request::_internal_chatroom() const {
  const ::client_server::ChatRoom* p = chatroom_;
  return p != nullptr ? *p : *reinterpret_cast<const ::client_server::ChatRoom*>(
      &::client_server::_ChatRoom_default_instance_);
}
inline const ::client_server::ChatRoom& Request::chatroom() const {
  // @@protoc_insertion_point(field_get:client_server.Request.chatRoom)
  return _internal_chatroom();
}
inline ::client_server::ChatRoom* Request::release_chatroom() {
  // @@protoc_insertion_point(field_release:client_server.Request.chatRoom)
  
  ::client_server::ChatRoom* temp = chatroom_;
  chatroom_ = nullptr;
  return temp;
}
inline ::client_server::ChatRoom* Request::_internal_mutable_chatroom() {
  
  if (chatroom_ == nullptr) {
    auto* p = CreateMaybeMessage<::client_server::ChatRoom>(GetArenaNoVirtual());
    chatroom_ = p;
  }
  return chatroom_;
}
inline ::client_server::ChatRoom* Request::mutable_chatroom() {
  // @@protoc_insertion_point(field_mutable:client_server.Request.chatRoom)
  return _internal_mutable_chatroom();
}
inline void Request::set_allocated_chatroom(::client_server::ChatRoom* chatroom) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete chatroom_;
  }
  if (chatroom) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      chatroom = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, chatroom, submessage_arena);
    }
    
  } else {
    
  }
  chatroom_ = chatroom;
  // @@protoc_insertion_point(field_set_allocated:client_server.Request.chatRoom)
}

// string info = 3;
inline void Request::clear_info() {
  info_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& Request::info() const {
  // @@protoc_insertion_point(field_get:client_server.Request.info)
  return _internal_info();
}
inline void Request::set_info(const std::string& value) {
  _internal_set_info(value);
  // @@protoc_insertion_point(field_set:client_server.Request.info)
}
inline std::string* Request::mutable_info() {
  // @@protoc_insertion_point(field_mutable:client_server.Request.info)
  return _internal_mutable_info();
}
inline const std::string& Request::_internal_info() const {
  return info_.GetNoArena();
}
inline void Request::_internal_set_info(const std::string& value) {
  
  info_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void Request::set_info(std::string&& value) {
  
  info_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:client_server.Request.info)
}
inline void Request::set_info(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  info_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:client_server.Request.info)
}
inline void Request::set_info(const char* value, size_t size) {
  
  info_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:client_server.Request.info)
}
inline std::string* Request::_internal_mutable_info() {
  
  return info_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Request::release_info() {
  // @@protoc_insertion_point(field_release:client_server.Request.info)
  
  return info_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Request::set_allocated_info(std::string* info) {
  if (info != nullptr) {
    
  } else {
    
  }
  info_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), info);
  // @@protoc_insertion_point(field_set_allocated:client_server.Request.info)
}

// -------------------------------------------------------------------

// RequestResult

// bool success = 1;
inline void RequestResult::clear_success() {
  success_ = false;
}
inline bool RequestResult::_internal_success() const {
  return success_;
}
inline bool RequestResult::success() const {
  // @@protoc_insertion_point(field_get:client_server.RequestResult.success)
  return _internal_success();
}
inline void RequestResult::_internal_set_success(bool value) {
  
  success_ = value;
}
inline void RequestResult::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:client_server.RequestResult.success)
}

// .client_server.Request request = 2;
inline bool RequestResult::_internal_has_request() const {
  return this != internal_default_instance() && request_ != nullptr;
}
inline bool RequestResult::has_request() const {
  return _internal_has_request();
}
inline void RequestResult::clear_request() {
  if (GetArenaNoVirtual() == nullptr && request_ != nullptr) {
    delete request_;
  }
  request_ = nullptr;
}
inline const ::client_server::Request& RequestResult::_internal_request() const {
  const ::client_server::Request* p = request_;
  return p != nullptr ? *p : *reinterpret_cast<const ::client_server::Request*>(
      &::client_server::_Request_default_instance_);
}
inline const ::client_server::Request& RequestResult::request() const {
  // @@protoc_insertion_point(field_get:client_server.RequestResult.request)
  return _internal_request();
}
inline ::client_server::Request* RequestResult::release_request() {
  // @@protoc_insertion_point(field_release:client_server.RequestResult.request)
  
  ::client_server::Request* temp = request_;
  request_ = nullptr;
  return temp;
}
inline ::client_server::Request* RequestResult::_internal_mutable_request() {
  
  if (request_ == nullptr) {
    auto* p = CreateMaybeMessage<::client_server::Request>(GetArenaNoVirtual());
    request_ = p;
  }
  return request_;
}
inline ::client_server::Request* RequestResult::mutable_request() {
  // @@protoc_insertion_point(field_mutable:client_server.RequestResult.request)
  return _internal_mutable_request();
}
inline void RequestResult::set_allocated_request(::client_server::Request* request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete request_;
  }
  if (request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, request, submessage_arena);
    }
    
  } else {
    
  }
  request_ = request;
  // @@protoc_insertion_point(field_set_allocated:client_server.RequestResult.request)
}

// -------------------------------------------------------------------

// VotingInfo

// .client_server.User requester = 1;
inline bool VotingInfo::_internal_has_requester() const {
  return this != internal_default_instance() && requester_ != nullptr;
}
inline bool VotingInfo::has_requester() const {
  return _internal_has_requester();
}
inline void VotingInfo::clear_requester() {
  if (GetArenaNoVirtual() == nullptr && requester_ != nullptr) {
    delete requester_;
  }
  requester_ = nullptr;
}
inline const ::client_server::User& VotingInfo::_internal_requester() const {
  const ::client_server::User* p = requester_;
  return p != nullptr ? *p : *reinterpret_cast<const ::client_server::User*>(
      &::client_server::_User_default_instance_);
}
inline const ::client_server::User& VotingInfo::requester() const {
  // @@protoc_insertion_point(field_get:client_server.VotingInfo.requester)
  return _internal_requester();
}
inline ::client_server::User* VotingInfo::release_requester() {
  // @@protoc_insertion_point(field_release:client_server.VotingInfo.requester)
  
  ::client_server::User* temp = requester_;
  requester_ = nullptr;
  return temp;
}
inline ::client_server::User* VotingInfo::_internal_mutable_requester() {
  
  if (requester_ == nullptr) {
    auto* p = CreateMaybeMessage<::client_server::User>(GetArenaNoVirtual());
    requester_ = p;
  }
  return requester_;
}
inline ::client_server::User* VotingInfo::mutable_requester() {
  // @@protoc_insertion_point(field_mutable:client_server.VotingInfo.requester)
  return _internal_mutable_requester();
}
inline void VotingInfo::set_allocated_requester(::client_server::User* requester) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete requester_;
  }
  if (requester) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      requester = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, requester, submessage_arena);
    }
    
  } else {
    
  }
  requester_ = requester;
  // @@protoc_insertion_point(field_set_allocated:client_server.VotingInfo.requester)
}

// .client_server.ChatRoom chatRoom = 2;
inline bool VotingInfo::_internal_has_chatroom() const {
  return this != internal_default_instance() && chatroom_ != nullptr;
}
inline bool VotingInfo::has_chatroom() const {
  return _internal_has_chatroom();
}
inline void VotingInfo::clear_chatroom() {
  if (GetArenaNoVirtual() == nullptr && chatroom_ != nullptr) {
    delete chatroom_;
  }
  chatroom_ = nullptr;
}
inline const ::client_server::ChatRoom& VotingInfo::_internal_chatroom() const {
  const ::client_server::ChatRoom* p = chatroom_;
  return p != nullptr ? *p : *reinterpret_cast<const ::client_server::ChatRoom*>(
      &::client_server::_ChatRoom_default_instance_);
}
inline const ::client_server::ChatRoom& VotingInfo::chatroom() const {
  // @@protoc_insertion_point(field_get:client_server.VotingInfo.chatRoom)
  return _internal_chatroom();
}
inline ::client_server::ChatRoom* VotingInfo::release_chatroom() {
  // @@protoc_insertion_point(field_release:client_server.VotingInfo.chatRoom)
  
  ::client_server::ChatRoom* temp = chatroom_;
  chatroom_ = nullptr;
  return temp;
}
inline ::client_server::ChatRoom* VotingInfo::_internal_mutable_chatroom() {
  
  if (chatroom_ == nullptr) {
    auto* p = CreateMaybeMessage<::client_server::ChatRoom>(GetArenaNoVirtual());
    chatroom_ = p;
  }
  return chatroom_;
}
inline ::client_server::ChatRoom* VotingInfo::mutable_chatroom() {
  // @@protoc_insertion_point(field_mutable:client_server.VotingInfo.chatRoom)
  return _internal_mutable_chatroom();
}
inline void VotingInfo::set_allocated_chatroom(::client_server::ChatRoom* chatroom) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete chatroom_;
  }
  if (chatroom) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      chatroom = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, chatroom, submessage_arena);
    }
    
  } else {
    
  }
  chatroom_ = chatroom;
  // @@protoc_insertion_point(field_set_allocated:client_server.VotingInfo.chatRoom)
}

// -------------------------------------------------------------------

// Vote

// bool approved = 1;
inline void Vote::clear_approved() {
  approved_ = false;
}
inline bool Vote::_internal_approved() const {
  return approved_;
}
inline bool Vote::approved() const {
  // @@protoc_insertion_point(field_get:client_server.Vote.approved)
  return _internal_approved();
}
inline void Vote::_internal_set_approved(bool value) {
  
  approved_ = value;
}
inline void Vote::set_approved(bool value) {
  _internal_set_approved(value);
  // @@protoc_insertion_point(field_set:client_server.Vote.approved)
}

// .client_server.VotingInfo voteInfo = 2;
inline bool Vote::_internal_has_voteinfo() const {
  return this != internal_default_instance() && voteinfo_ != nullptr;
}
inline bool Vote::has_voteinfo() const {
  return _internal_has_voteinfo();
}
inline void Vote::clear_voteinfo() {
  if (GetArenaNoVirtual() == nullptr && voteinfo_ != nullptr) {
    delete voteinfo_;
  }
  voteinfo_ = nullptr;
}
inline const ::client_server::VotingInfo& Vote::_internal_voteinfo() const {
  const ::client_server::VotingInfo* p = voteinfo_;
  return p != nullptr ? *p : *reinterpret_cast<const ::client_server::VotingInfo*>(
      &::client_server::_VotingInfo_default_instance_);
}
inline const ::client_server::VotingInfo& Vote::voteinfo() const {
  // @@protoc_insertion_point(field_get:client_server.Vote.voteInfo)
  return _internal_voteinfo();
}
inline ::client_server::VotingInfo* Vote::release_voteinfo() {
  // @@protoc_insertion_point(field_release:client_server.Vote.voteInfo)
  
  ::client_server::VotingInfo* temp = voteinfo_;
  voteinfo_ = nullptr;
  return temp;
}
inline ::client_server::VotingInfo* Vote::_internal_mutable_voteinfo() {
  
  if (voteinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::client_server::VotingInfo>(GetArenaNoVirtual());
    voteinfo_ = p;
  }
  return voteinfo_;
}
inline ::client_server::VotingInfo* Vote::mutable_voteinfo() {
  // @@protoc_insertion_point(field_mutable:client_server.Vote.voteInfo)
  return _internal_mutable_voteinfo();
}
inline void Vote::set_allocated_voteinfo(::client_server::VotingInfo* voteinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete voteinfo_;
  }
  if (voteinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      voteinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, voteinfo, submessage_arena);
    }
    
  } else {
    
  }
  voteinfo_ = voteinfo;
  // @@protoc_insertion_point(field_set_allocated:client_server.Vote.voteInfo)
}

// .client_server.User voter = 3;
inline bool Vote::_internal_has_voter() const {
  return this != internal_default_instance() && voter_ != nullptr;
}
inline bool Vote::has_voter() const {
  return _internal_has_voter();
}
inline void Vote::clear_voter() {
  if (GetArenaNoVirtual() == nullptr && voter_ != nullptr) {
    delete voter_;
  }
  voter_ = nullptr;
}
inline const ::client_server::User& Vote::_internal_voter() const {
  const ::client_server::User* p = voter_;
  return p != nullptr ? *p : *reinterpret_cast<const ::client_server::User*>(
      &::client_server::_User_default_instance_);
}
inline const ::client_server::User& Vote::voter() const {
  // @@protoc_insertion_point(field_get:client_server.Vote.voter)
  return _internal_voter();
}
inline ::client_server::User* Vote::release_voter() {
  // @@protoc_insertion_point(field_release:client_server.Vote.voter)
  
  ::client_server::User* temp = voter_;
  voter_ = nullptr;
  return temp;
}
inline ::client_server::User* Vote::_internal_mutable_voter() {
  
  if (voter_ == nullptr) {
    auto* p = CreateMaybeMessage<::client_server::User>(GetArenaNoVirtual());
    voter_ = p;
  }
  return voter_;
}
inline ::client_server::User* Vote::mutable_voter() {
  // @@protoc_insertion_point(field_mutable:client_server.Vote.voter)
  return _internal_mutable_voter();
}
inline void Vote::set_allocated_voter(::client_server::User* voter) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete voter_;
  }
  if (voter) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      voter = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, voter, submessage_arena);
    }
    
  } else {
    
  }
  voter_ = voter;
  // @@protoc_insertion_point(field_set_allocated:client_server.Vote.voter)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace client_server

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::client_server::Request_RequestType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::client_server::Request_RequestType>() {
  return ::client_server::Request_RequestType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_client_5fserver_2eproto
